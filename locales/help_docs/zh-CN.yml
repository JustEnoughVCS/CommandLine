# l10n file - zh-CN - 简体中文

# 文本中可使用以下语法
# 1. **粗体**
# 2.  *斜体*
# 3. [[red]]颜色[[/]]
# 4. `文本`（自动着色绿色）
# 5. <文本>（自动着色青色）
#
# 对于颜色的使用，请参考：
# RED     = 紧急情况，错误
# YELLOW  = 警告
#
# CYAN    = 强调
# GREEN   = 文本内容
#
# GRAY    = 不强调，忽略
# GREY    = 同上
#
# 对于 分析器 结果：
# YELLOW  = 移动操作 = ">" 符号
# GREEN   = 创建操作 = "+" 符号
# RED     = 丢失操作 = "-" 符号
# MAGENTA = 擦除操作 = "&" 符号
# CYAN    = 修改操作 = "*" 符号

common:
  confirm: |
    是否执行上述操作？（Y/n）：

  word:
    version: 版本
    cli_version: 命令行版本
    vcs_version: 核心库版本

jvv:
  version:
    header: |
      JVCS 上游管理工具 - %{version}（核心：[[cyan]]%{vcs_version}[[/]]）

    compile_info: |
      编译信息：
        时间：[[cyan]]%{build_time}[[/]]
        目标：[[cyan]]%{build_target}[[/]]
        平台：[[cyan]]%{build_platform} - %{build_toolchain}[[/]]

        核心库：[[cyan]]%{core_build_branch}[[/]] (Commit: %{core_build_commit})
        命令行：[[cyan]]%{cli_build_branch}[[/]] (Commit: %{cli_build_commit})

  help: |
    **JustEnoughVCS 上游库命令**
    该程序直接创建、管理、运行 JustEnoughVCS 的上游库
    **注意**：它能直接操作库的数据，请谨慎使用！*（能力越大，责任越大）*

    **创建库**：
      create <名称>         - 在给定的目录名称中创建库
      init                  - 在当前目录中创建库

    **查询**：
      here                  - 查询当前库的信息

    **成员管理**：
      member [list|register|remove]
        list                - 列出成员
        register <成员名称> - 注册成员
        remove   <成员名称> - 移除成员

    **服务**：
      service listen        - 运行服务端

    另外，您可以使用 jvv <命令名称> --help 来查询更详细的帮助！

  here: |
    **显示此处库的信息**
    **例如**：cd ./您需要查询的库/ && jvv here

  create: |
    **在给定的目录名称中创建库**
    **用法**：jvv create **<库名称>**

    **例如**：jvv create MyVault
    上述操作会在当前目录创建目录 MyVault，然后在该目录内初始化库

  init: |
    **在当前目录创建库**
    **用法**：jvv init

    该命令会在当前所在的目录创建库，库名称由当前所在目录名称决定

  member: |
    **成员管理**
    **用法**：jvv member <register/remove> <成员名称>

    根据给定的 成员名称，注册（若不存在）或移除（若存在）指定成员

    推荐使用 "snake_case" 命名格式，因为在配置文件中将以该格式存储
    **例如**：jvv member register vault_member

    **查询**：jvv member list
    该命令的效果和在库的成员目录中执行 jvv here 命令等效

    **注意**：该命令不会影响到库中私钥目录，请手动添加或删除私钥！

  service: |
    **服务设置相关**
    **用法**：
    jvv service listen - 在当前库中启动服务器，以接受客户端连接
      您可以使用 --port 来设定监听的端口，使用 --no-log 禁用日志输出

  info:
    here:
      analyzing_size: 正在分析库存储大小...

  fail:
    jvcs: JustEnoughVCS 错误：%{err}
    no_vault_here: 此处并没有找到库文件

    tokio:
      fs:
        create_dir: 无法创建目录 %{dir}
        create_dir_all: 无法创建目录 %{dir}

    std:
      current_dir: 无法获得当前目录
      current_dir_name: 无法获得当前目录的名称
      set_current_dir: 无法设置到目录 %{dir}

    here:
      cfg_not_found: |
        无法找到库的配置！
        若您希望将该目录作为库，请使用 jvv init --help 查看相关帮助

      vault_init_failed: 初始化库失败！
      size_calc_error: 计算库存储大小失败！
      member_ids_failed: 获得成员 ID 失败！
      ref_sheet_not_found: 未找到参考表 `ref`，该参考表理应存在！

    create:
      not_empty: 禁止的操作！指定的目录已经存在

    init:
      not_empty: 禁止的操作！该目录不为空

    member:
      register: 创建成员失败！请检查是否存在同名的成员
      list: 获取成员 ID 失败！

    service:
      listen_done: |
        服务端被错误强制关闭！
        错误信息：%{error}

      wtf_show_log_and_no_log: |
        您无法同时选择显示和不显示输出信息！

        “
        这让我想起那个古老的寓言：一位卖矛和盾的商人，先是夸口他的盾‘任何矛都刺不穿’，
        接着又宣称他的矛 ‘能刺穿任何盾’。当被问到 ’用你的矛刺你的盾会怎样’ 时，他哑口无言。
        ”

        您的指令就像这则故事，既要显示日志，又要不显示日志。我该遵循哪个矛盾的命令呢？

        **提示**：使用 `jvv listen --no-log` 或 `jvv listen --show-log` 覆盖默认 Logger 设置运行

  success:
    here:
      info: |
        找到库 *`%{name}`*！（%{num_mem} 成员，%{num_pk} 位已注册公钥）
        其中，管理着 %{num_sheets} 张表，%{num_vf} 个虚拟文件，总共 %{total_size}

        **提示**：若要启动服务端，请运行 jvv service listen

    create: 成功在 `%{name}` 创建库！
    init: 在此处初始化库成功！

    member:
      register: 创建成员 `%{member}` 成功！
      remove: 好的， `%{member}` 已不再存在于库中（或本就不在？）！
      list:
        header: |
          **当前库中有 %{num} 名成员：**

        footer: |
          **其中，有 %{num} 名成员注册了公钥**

        status_key_registered: (公钥存在)

    service:
      listen_start: 正在库 `%{path}` 监听来自客户端的连接 ...
      listen_done: 服务端运行结束！

jv:
  version:
    header: |
      JVCS 命令行工具 - [[cyan]]%{version}[[/]]（核心：[[cyan]]%{vcs_version}[[/]]）

    compile_info: |
      编译信息：
        时间：[[cyan]]%{build_time}[[/]]
        目标：[[cyan]]%{build_target}[[/]]
        平台：[[cyan]]%{build_platform} - %{build_toolchain}[[/]]

        核心库：[[cyan]]%{core_build_branch}[[/]] (Commit: %{core_build_commit})
        命令行：[[cyan]]%{cli_build_branch}[[/]] (Commit: %{cli_build_commit})

  tip:
    not_workspace: |
      当前不在工作区目录，您可使用 `jv create <名称>` 或 `jv init` 创建工作区

    no_account: |
      您的计算机没有任何账户注册，可使用 `jv account add <账户名称>` 以创建账户

    no_account_set: |
      当前工作区的账户为 `unknown`，这意味着您并未设置账户
      使用   `jv as <账户名称>` 来为工作区指定账户
      或使用 `jv login <账户名称> <上游地址>` 来关联至上游库

    account_not_exist: |
      当前工作区设置的账户 `%{account}` 并未注册至您的计算机

    outdated: |
      工作区内信息已经 %{hour} 小时 %{minutes} 分钟没有更新了
      请使用 `jv update` 拿到最新信息

  help: |
    **JustEnoughVCS 本地工作区命令**
    该程序将连接至上游库，用以同步、更新本地工作区文件的变化，以供协同创作

    **常用别名**：
      jv u 下载最新信息，jv t 追踪文件，jv a 对齐文件结构到表，jv in/out 导入或导出文件

    **上游库**：
      login  <账户> <地址>    - 设置账户、定向并获得上游信息    [[cyan]][远程][[/]]
      direct <地址>           - 定向到工作区到上游库            [[cyan]][远程][[/]]
      unstain                 - 祛色工作区，清除关联
      update                  - 同步最新的信息                  [[cyan]][远程][[/]]

    **账户**：
      account [list|as|add|remove|movekey|genpub]
        list                  - 列出所有账户
        as      <账户名称>    - 设置该工作区使用的账户

        add     <账户名称>    - 为当前计算机添加账户
        remove  <账户名称>    - 从计算机删除账户

        movekey <账户> <私钥> - 移动私钥文件到指定账户
        genpub  <账户> <目录> - 输出公钥文件到指定目录

    **表操作**：
      sheet [list|use|exit|make|drop|align]
        list                   - 列出所有表
        use                    - 使用表，并开始工作
        exit                   - 退出表，清除当前修改
        make                   - 创建新表以供自己使用            [[cyan]][远程][[/]]
        drop                   - 抛弃表以供他人使用              [[cyan]][远程][[/]]
        align                  - 对齐文件结构到表                [[cyan]][远程][[/]]

    **上下文查询**：
      here                     - 显示当前路径的相关信息
      status                   - 显示当前表的状态信息
      info <文件>              - 显示单个文件的状态

    **文件传递**：
      share <文件> <表> <描述> - 分享映射到其他表                [[cyan]][远程][[/]]
      share <分享ID>           - 将分享导入到当前表              [[cyan]][远程][[/]]
      share <REF表> <文件>     - 从其他参考表中导入映射          [[cyan]][远程][[/]]

    **文件操作**：
      move  <文件> <到>        - 安全地重命名文件                [[cyan]][远程][[/]]
      track <文件>             - 追踪文件内容到最新版本          [[cyan]][远程][[/]]
      hold  <文件>             - 拿取文件，同步版本并获得编辑权  [[cyan]][远程][[/]]
      throw <文件>             - 丢弃文件，同步版本并放弃编辑权  [[cyan]][远程][[/]]
      jump  <文件> <版本>      - 将文件的版本跳转至其他版本      [[cyan]][远程][[/]]

    **内建文档**：
      docs list                - 列出所有可用的文档
      docs <文档名称>          - 查看指定文档的内容

    您可以使用 jv <命令名称> --help 来查询更详细的帮助！

    **提示**：若您需要了解 JustEnoughVCS 的协作范式，请使用 jv docs get_started

  account: |
    **管理本地账户**
    **用法**：
    jv account list - 列出该计算机所有的账户，以及是否注册私钥
    jv account as <账户名称> - 切换当前账户
    jv account as host/<账户名称> - 以 Host 模式切换账户
    jv account add <账户名称> - 为当前计算机添加账户
    jv account remove <账户名称> - 删除该账户
    jv account movekey <账户名称> <私钥文件> - 移动私钥到指定账户
    jv account genpub <账户名称> <输出目录> - 将公钥输出至某个目录，留空为当前

    **提示**：使用 jv account add <账户名称> --keygen 可以自动为您的账户生成 ED25519 私钥
    **注意**：`--keygen` 和 `genpub` 都需要您的计算机能够直接调用 OpenSSL 命令行工具

    账户是本地计算机上的身份标识，每个账户可以关联不同的私钥
    您需要先设置账户才能与上游库进行交互

  sheet: |
    **管理表**
    **用法**：
    jv sheet list - 列出上游工作区的所有表

    jv sheet use <表名称> - 使用指定的表开始当前工作（不存在则自动创建）
    jv sheet exit - 退出当前工作

    jv sheet make <表名称> - 为自己创建一张新的表
    jv sheet drop <表名称> - 将表抛弃，以供其他人使用

    **对齐**：
    jv sheet align - 查看所有需要对齐的项

    对于移动项：
    jv sheet align <项> [local/remote] - 对齐指定移动项
    jv sheet align moved [local/remote] - 对齐所有移动项
    jv sheet align moved break - 断开所有移动项

    对于丢失项：
    jv sheet align <项> <创建项> - 指向创建项，以确认移动
    jv sheet align <项> confirm - 确认该文件已丢失
    jv sheet align lost confirm - 确认所有丢失项

    对于擦除项：
    jv sheet align <项> confirm - 确认该文件已擦除
    jv sheet align erased confirm - 确认所有擦除项

    jv sheet align --work - 使用编辑器模式对齐文件

    表是 JustEnoughVCS 中的核心概念，每张表代表一块独立的文件结构
    您可以在不同的表之间切换工作，或者将文件从一张表导出到另一张表

  create: |
    **创建指定名称的工作区**
    **用法**：jv create <工作区名称>

    **例如**：jv create my_workspace
    上述操作会在当前目录创建名为 my_workspace 的目录，并在其中初始化工作区

    工作区是您本地的工作环境，用于与上游库进行文件同步和版本控制

  init: |
    **在此目录创建工作区**
    **用法**：jv init

    该命令会在当前所在的目录创建工作区，工作区名称由当前所在目录名称决定

    如果当前目录不为空，该操作将会失败，请确保在空目录中执行此命令

  here: |
    **查询此处目录信息**
    **用法**：jv here

    显示当前目录文件的详细信息，包括：
    - 文件名称、大小、版本号
    - 文件当前的持有人
    - 文件最新版本的更新信息

    **提示**：使用 `jv here --desc` 查看本地文件最后一次的更新信息

  status: |
    **显示当前表的状态信息**
    **用法**：jv status

    显示当前表的文件修改状态：
    - 新增、删除的文件
    - 移动的文件
    - 修改的文件

    这是了解当前表文件状态的快速方式

  info: |
    **显示文件详细信息**
    **用法**：jv info <文件路径>
    使用 `--full` 查看完整的更新记录

    显示指定文件的详细信息，包括：
    - 文件的历史变更
    - 文件在 `ref` 中的位置
    - 文件在 `ref` 中的版本

  track: |
    **追踪文件至最新事实**
    **用法**：jv track <文件路径>

    它不是上传，也不是下载，而是对 [[cyan]]“哪一个版本应被视为事实”[[/]] 的结果声明。

    **创建**
    当工作区存在未被追踪的文件时，该文件尚不存在于公认事实中
    执行追踪将创建该文件的事实版本，写入您的表，并授予您编辑权
    此时，您是 **该事实的撰写者**

    **更新**
    当您持有文件，且基于当前最新事实进行编辑时，
    您工作区中的版本将被视为新的最新事实
    执行追踪将 **更新该事实到上游**

    **同步**
    当您不持有文件、基于过期事实编辑，或本地不存在该文件时，
    您的修改不具备事实效力，一切以上游最新版为准
    执行追踪将 **同步上游事实到本地**
    若需覆盖本地修改，必须显式指定 `--overwrite`

  hold: |
    **拿取文件：从上游库获得该文件的编辑权**
    **用法**：jv hold <文件路径>

    **例如**：jv hold src/lib.rs
    当您需要编辑某个文件时，必须先持有该文件的编辑权
    持有文件后，其他协作者将无法同时编辑该文件，避免冲突

    编辑完成后，请记得追踪文件以保存更改

  throw: |
    **丢弃文件：从上游库放弃该文件的编辑权**
    **用法**：jv throw <文件路径>

    **例如**：jv throw src/config.rs
    当您不再需要编辑某个文件时，可以丢弃该文件的编辑权
    丢弃后，其他协作者就可以持有并编辑该文件

    如果您对文件进行了更改但尚未追踪，丢弃操作会丢失这些更改

  move: |
    **移动映射**
    **用法**：
    jv move <映射> <目标映射> - 修改上游映射
    jv move <映射> --erase - 擦除上游映射

    **例如**：
    jv move draft/character.png done/character.png - 移动映射
    jv move character.png player.png - 重命名
    jv move . ../publish/ - 批量移动
    jv move temp/ --erase - 擦除映射

    移动映射操作会修改上游的映射，并同步修改本地结构（使用 `--only-remote` 取消同步修改）
    在移动完成后，通常需要 `jv align moved remote` 将本地结构同步至上游

  share: |
    **分享文件的可见性**
    **用法**：
    jv share <文件> <表> <描述> - 分享映射到其他表
    jv share <分享ID> - 将分享导入到当前表
    jv share <REF表> <文件> - 从其他参考表中导入映射

    jv shares - 查看传入的分享

    **提示**：import 命令可使用如下参数
      --only-remote - 只在表中导入映射，不修改本地结构
      --strict - 严格的导入模式，拒绝所有冲突，这是默认的方案
      --skip - 跳过冲突项
      --overwrite - 强制覆盖冲突的映射，危险的操作

    **分享** 是将文件可见性交由其他人的最简途径

  direct: |
    **定向到指定上游库，并染色该工作区**
    **用法**：jv direct <上游库地址>

    **例如**：jv direct your_vault.org
    该操作会将当前工作区连接到指定的上游库，并为工作区添加染色标识

    染色后，该工作区将只能与指定标识的库进行交互，确保数据一致性

  unstain: |
    **为工作区祛色**
    **用法**：jv unstain

    **危险操作**：该操作会移除工作区的染色标识，此后该工作区将与上游库断开连接

    祛色后，工作区将不再与任何特定库关联，可以重新连接到其他库
    但请注意，这可能会导致数据同步问题，请谨慎使用

  update: |
    **从上游库下载最新的信息**
    **用法**：jv update

    该操作会从上游库同步最新的文件状态、表信息和成员信息

    建议在开始工作前先执行更新操作，确保您拥有最新的工作环境

  docs: |
    **查询内建文档**
    **用法**：
    jv docs list - 列出所有可用的文档
    jv docs <文档名称> - 查看指定文档的内容
    jv docs <文档名称> -d - 直接打印内容

    **例如**：
    jv docs get_started
    jv docs collaboration -d

    内建文档包含 JustEnoughVCS 的使用指南、协作范式和最佳实践

  confirm:
    login: |
      您正在以 %{account} 身份登陆上游库 %{upstream}，请确认

    unstain: |
      此操作将会断开当前工作区与上游库 `%{upstream}` 的关联
      若重新连接至标识不匹配的库，会导致严重的问题，请谨慎操作！

    direct: |
      是否需要将当前本地工作区定向到上游库 %{upstream}？

    sheet:
      make:
        restore: |
          似乎 `%{sheet_name}` 是一张无人认领的表，是否拿到它的所有权？
          如果您不想拿到该表，请使用别的名称建立表

      drop: |
        是否要放弃表 `%{sheet_name}` 的所有权，此后，您将无法在表中工作！

    track:
      prepare: |
        您正在准备追踪 %{file_counts} 个文件的变更，这些文件将遵循如下规则：
        1. 新文件，将被上传并加入您的表中管理
        2. 已持有文件，除非本地不存在或版本不匹配，否则永远执行上传操作
        3. 未持有文件，除非冻结版本，否则永远执行下载和更新最新版本

        **当前**：
        **下行**：%{old_files} 个待同步，%{download_files} 个待下载
        **上行**：%{new_files} 个待追踪，%{modified_files} 个待更新

  fail:
    std:
      current_dir: 无法获得当前目录
      current_dir_name: 无法获得当前目录的名称
      set_current_dir: 无法设置到目录 %{dir}

    not_root_dir: 该命令需要在工作区根目录运行！

    move:
      rename_failed: |
        **警告**：移动本地文件 `%{from}` 至 `%{to}` 失败：%{error}

      has_rename_failed: |
        **提示**：因为已跳过文件的移动，所以会产生偏差，
        在可移动文件后，请务必使用 `jv align` 解决偏差

      no_target_dir: |
        您未指定需要移动的目录！
        请使用 `jv move <映射> <目标映射名>` 的方式移动映射
        或使用 `jv move <映射> --erase` 将映射擦除

      count_doesnt_match: |
        您指定了多个映射，但目标地址为单个映射
        请使用 `jv move 多个映射 目录/` 来移动多个映射
        或使用 `jv move 单个映射 映射名称` 来重命名该映射

    format_path: |
      格式化目录 %{path} 失败：%{error}.

    path_not_found: |
      您给出的目录 `%{path}` 无法找到！

    parse:
      parser_failed: |
        错误的命令输入！
        请使用 `jv -h` 查看帮助

      str_to_sockaddr: |
        错误：%{err}
        无法将 *`%{str}`* 识别为有效地址，请检查您的输入！

    from_core: |
      **错误**：`%{err}`（该错误来自核心调用）

    sheet:
      align:
        no_direction: |
          无法确认对齐的方式！

        align_item_not_found: |
          无法找到该对齐项！

        unknown_moved_direction: |
          未知的对齐方向！
          请使用 `local` 或 `remote` 来表示路径基于本地位置或远程位置

        target_exists: |
          无法对齐本地文件 `%{local}` 至远程地址 `%{remote}`
          因为此处已存在其他文件，请移走该文件，并再次对齐！

        move_failed: |
          移动本地文件失败：%{err}
          **提示**：请检查文件权限或路径是否正确

        remove_mapping_failed: |
          移除本地映射失败：%{err}

        delete_mapping_failed: |
          从本地表中删除映射失败：%{err}
          **提示**：请检查本地表配置文件

        no_lost_matched: |
          未找到匹配的丢失项！

        no_created_matched: |
          未找到匹配的创建项！

        too_many_lost: |
          匹配到多个丢失项！

        too_many_created: |
          匹配到多个创建项！

        calc_hash_failed: |
          无法计算文件 `%{file}` 的哈希值

        mapping_not_found: |
          未找到本地映射 `%{mapping}`！

    account:
      no_user_dir: 无法找到用户目录！
      add: 添加账户 `%{account}` 失败，请检查账户是否已存在。
      remove: 删除账户 `%{account}` 失败，请检查账户是否存在。
      list: 获取账户列表失败！
      move_key: 将该私钥移动至账户目录失败！
      not_found: 无法找到账户 `%{account}`!
      no_key_registered: 账户 `%{account}` 没有注册私钥！
      as: 设置当前账户失败，请确保当前表已退出
      keygen: 生成私钥失败！请尝试手动生成私钥
      keygen_exec: |
        运行 OpenSSL 失败！
        请检查您的计算机中是否安装 OpenSSL
      generate_pub_key: |
        生成公钥失败！
        请检查 OpenSSL 是否安装，或手动生成公钥

    init_create_dir_not_empty: |
      当前目录并不是空的！
      若您确实确定在此处创建，请使用 --force 来强制执行！

    create: 创建本地工作区失败！
    init: 在此处创建本地工作区失败！
    get_current_dir: 无法获得当前目录！

    workspace_not_found: |
      无法找到本地工作区！请在本地工作区内使用该命令
      若您希望将该目录作为本地工作区，请使用 jv init

    read_cfg: 无法读取本地工作区的配置文件！
    write_cfg: 无法将修改写入本地工作区的配置文件！

    create_socket: 无法创建 TCP 套接字！
    connection_failed: 无法连接至目标服务器！

    unstain: |
      当前工作区并未被染色，无需祛色

    not_stained: |
      当前工作区并未被染色，无法执行下一步操作！
      **提示**：请先使用 `jv direct <上游地址>` 定向到上游库

    change_edit_right:
      no_selection: 您未选中任何文件！
      check_failed: |
        在您选中的 %{num} 个文件中，存在预检查失败的项！
        在命令后添加 `--details` 查看具体事项

        **提示**：
        添加 `--skip-failed` 可跳过当前检查失败的项进行操作
        添加 `--force` 可无视检查进行操作 (不安全的操作)

      check_failed_details: |
        在您选中的 %{num} 个文件中，有 %{failed} 个文件预先检查未通过！
        %{items}

      check_fail_item: |
        %{path}（%{reason}）

      check_fail_reason:
        not_found_in_sheet: 表中不存在
        not_a_tracked_file: 文件未被跟踪
        base_version_unmatch: 基准版本不匹配
        not_holder: 期望丢弃，但不是持有者
        has_holder: 期望持有，但被 %{holder} 持有
        already_held: 文件已持有
        already_modified: 文件已修改

    docs:
      not_found: 文档 `%{docs_name}` 未找到！
      no_doc_dir: |
        无法找到暂存目录！
        **提示**：您也可以使用 `jv docs %{docs_name} -d` 直接打印
      open_editor: |
        无法打开文本编辑器预览：`%{err}`！
        **提示**：您也可以使用 `jv docs %{docs_name} -d` 直接打印

    track:
      no_selection: |
        您未在此次操作中选中任何文件！

        **提示**：如果您输入了内容依旧如此，
        可能因为您传入的目录在工作区目录以外，工作区之外的路径会被忽略

    status:
      no_sheet_in_use: |
        您并没有使用任何一张表！无法在此情况下分析工作区状态
        **提示**：您可以使用 `jv use <表名>` 选择并使用一张表

      analyze: |
        分析本地工作区的状态失败！

    use:
      sheet_not_exists: |
        表 `%{name}` 不存在！
        **提示**：请使用 `jv update` 更新工作区状态

      directory_not_empty: |
        在没有使用表的时候，工作区不应该存在任何文件！
        **提示**：请保证工作区是干净的，再使用 `jv use <表名>` 选择并使用一张表

  success:
    account:
      as: 成功将此工作区的账户切换至 `%{account}`
      as_host: |
        切换到账户：`host/%{account}`
        若 Host 身份受上游库认可，便可控制所有的表、映射
        请牢记："*能力越大，责任越大*"
      add: 成功添加账户 `%{account}`！
      remove: 成功删除账户 `%{account}`！
      list:
        header: |
          **当前计算机上有 %{num} 个账户：**

        status_has_key: (已注册私钥)
      move_key: 成功将该私钥移动至账户目录！
      generate_pub_key: 成功在 `%{export}` 生成公钥，请将它交给上游库管理员！
    create: 成功创建本地工作区！
    init: 成功在此处创建工作区！
    unstain: |
      成功祛色！
      当前工作区不再属于任何上游库，请工作前定向至新的上游库
      **提示**：使用 `jv direct <上游库地址>` 重新定向至新的上游库

    sheet:
      list:
        your_sheet: |
          **您可见的表**：
        your_sheet_item: |
          %{number}. %{name}
        your_sheet_item_use: |
          %{number}. %{name} [[green]][当前][[/]]
        reference_sheet_suffix: |
          [参考]
        other_sheet: |
          **其他表**：
        other_sheet_item: |
          %{number}. %{name}（属于 `%{holder}`）
        other_sheet_item_no_holder: |
          %{number}. %{name}（无人认领）
        tip_has_sheet: |
          您不在任何一张表，可使用 `jv use <表名>` 使用一张表
        tip_no_sheet: |
          **没有可以编辑的表！**
          您没有任何一张表，可使用 `jv make <表名>` 创建一张新表

      align:
        list: |
          您的本地工作区有如下变更待处理：
          %{tasks}

        task_name: 项名称
        local_path: 本地文件
        remote_path: 远程文件

        no_changes: |
          很好，本地工作区未产生结构偏差，无需对齐！

        suggestion_1: |
          **建议**：确认 [[magenta]]擦除项[[/]]
          **例如**：使用 `jv align %{example_erased} confirm` 来确认该 [[magenta]]擦除项[[/]]！

          [[yellow]]**注意**：确认后，本地映射将被擦除，同时，该位置的文件将被移走[[/]]

        suggestion_2: |
          **建议**：确认 [[red]]丢失项[[/]]
          无法确认文件丢失意图为 [[red]]删除[[/]] 或 [[yellow]]移动[[/]]！
          **例如**：使用 `jv align %{example_lost} <行为>` 来处理该 [[red]]丢失项[[/]]

          **确认删除**：填写 `confirm` 来确认您的操作是一次 [[red]]删除[[/]]
          **声明移动**：填写 [[green]]创建项[[/]] 与其形成 [[yellow]]移动[[/]] 关系

        suggestion_3: |
          **建议**：对齐 [[yellow]]移动项[[/]]，确认移动基于 本地 或 远程
          **例如**：使用 `jv align moved [local|remote]`          批量对齐
              或使用 `jv align %{example_moved} [local|remote]` 精确对齐移动
          若该移动并非您期望的，
                使用 `jv align %{example_moved} break` 断开它们

          **对齐至本地**：联网，修改上游映射至本地位置
          **对齐至远程**：脱机，将本地文件移至上游位置

    docs:
      list:
        header: |
          您可以查阅以下文档：

        item: |
          %{num}. %{docs_name}

        footer: |
          **提示**：使用 `jv docs <文档名称>` 查看文档，使用 -d 直接输出

    here:
      items:
        name: 名称
        version: 版本
        holder: 持有者
        size: 大小
        editing: 状态
        description: 描述

      path_info: |
        所在：%{upstream}/%{account}/%{sheet_name}/%{path}（%{minutes} 分钟前）

      ghost_directory_item_info: |
        ? %{directory_name}/

      ghost_file_item_info: |
        ? %{file_name}

      directory_item_info: |
        %{directory_name}/

      file_item_info: |
        %{file_name}

      append_info:
        holder:
          yourself: |
            你

          others: |
            %{holder}

        size: |
          %{size}

        name: |
          %{name}

        version:
          unmatch: |
            %{remote_version}*

          match: |
            %{version}

        editing:
          cant_edit: |
            只读

          cant_edit_but_modified: |
            只读*

          can_edit: |
            读写

          modified: |
            读写*

          not_local: |
            远程

        description: |
          @%{creator}: %{description}

      count_info: |
        %{dir_count} 目录、%{file_count} 文件，共计 %{size}

    info:
      oneline:
        table_headers:
          prefix: _
          version: 版本
          creator: 作者
          description: 描述
        description_current: 正在编辑中 ...

    status:
      struct_changes_display: |
        表 %{sheet_name} 的状态基于 %{h} 小时 %{m} 分钟 %{s} 秒前

        您的工作区处于结构变更状态：
        %{moved_items}%{lost_items}%{erased_items}%{created_items}
        **提示**：使用 `jv align` 对齐移动、丢失和擦除变更，
              使用 `jv track` 追踪创建变更

      content_modifies_display: |
        表 %{sheet_name} 的状态基于 %{h} 小时 %{m} 分钟 %{s} 秒前

        您的工作区处于内容变更状态：
        %{modified_items}

        **提示**：使用 `jv track` 追踪您的变更

      no_changes: |
        所在表 %{sheet_name}，状态基于 %{h} 小时 %{m} 分钟 %{s} 秒前
        您的工作区与上游保持同步，可基于该状态进行结构、内容的编辑！

      no_changes_in_reference_sheet: |
        所在表 %{sheet_name}，状态基于 %{h} 小时 %{m} 分钟 %{s} 秒前

      created_item: |
        +   创建：      %{path}

      lost_item: |
        -   丢失：      %{path}

      moved_item: |
        \>   移动：远程  %{from}
                  本地  %{to}

      erased_item: |
        &   擦除：      %{path}

      modified_item: |
        \*   修改：      %{path}

      invalid_modified_item: |
        x   修改：      %{path}（%{reason}）

      invalid_modified_reasons:
        not_holder: 不持有但被修改
        base_version_mismatch: 基于的编辑版本不匹配

      no_structure_changes: |
        无文件结构变更

      no_file_modifications: |
        本地无内容修改

      hint_in_reference_sheet: |
        您正在以**只读模式**访问**参考表**
        您可以查看文件内容、分享可见性、修改持有权
        但无法修改结构或提交内容

      hint_as_host: |
        [[yellow]]您正处于 Host 模式。[[/]]
        在此模式下，您将作为仓库结构与版本推进的最终解释者，
        您的操作将直接影响他人的工作状态，且不一定可逆。

        **结构维护**
        1. 您可以使用 `jv align` 或 `jv move` 编辑参考表结构
        2. 您可以使用 `jv make` 创建新的参考表，
           或将某张无人持有的表转换为参考表

        **状态裁决**
        3. 您可以使用 `jv throw` 强制收回所有人的编辑权
        4. 您可以使用 `jv drop` 强制丢弃其他人的表

        **事实推进**
        5. 您可以在任何表中使用 `jv track` 推进文件版本

        [[red]]**请牢记**：Host 并非 管理员模式，
        而是对他人结构、历史与解释权的最终承担者。
        您的每一次操作，都会成为他人必须接受的事实。[[/]]

  result:
    common:
      not_allowed_in_reference_sheet: |
        不允许在参考表中执行此操作！
        您不能对参考表进行任何结构更改，因为您并非参考表的维护者

        **提示**：若您在本地产生了移动需要对齐，
        使用 `jv align moved remote` 还原移动
      authroize_failed: 身份认证失败：%{err}！
      unknown: |
        未知结果！

    direct:
      redirected: |
        成功重定向到上游库 `%{upstream}`！

      redirect_failed: |
        重定向失败：%{err}！

      directed_and_stained: |
        成功定向到上游库 `%{upstream}`！
        工作区已被 **染色**，现可开始工作！

      already_stained: |
        当前工作区已被染色，无法定向其他不同标识的上游库
        请先使用 jv unstain 祛色

      same_upstream: |
        当前上游和给出的一致，无需重定向

    update:
      success: |
        已同步至最新信息！

      fail:
        sync_cached_sheet_fail:
          path_already_exist: |
            在同步上游信息至本地时发生了错误：本地已存在 %{path}，但是某个移动项需要移动到此处。
            请尝试移动该项至其他路径，再重新输入 `jv update`

    sheet:
      make:
        success: |
          成功创建表 `%{name}`！
          上游信息已变更，请使用 `jv update` 同步至最新信息

        success_restore: |
          成功恢复表 `%{name}` 的所有权！
          上游信息已变更，请使用 `jv update` 同步至最新信息

        sheet_already_exists: |
          表 `%{name}` 已存在，并由其他成员所持有！

        sheet_creation_failed: |
          表创建失败：`%{err}`

      drop:
        success: |
          成功放弃表 `%{name}` 的所有权！
          上游信息已变更，请使用 `jv update` 同步至最新信息
          **提示**：您可以使用 `jv make %{name}` 赎回该表

        sheet_in_use: |
          表 `%{name}` 正在被使用中，无法放弃！
          **提示**：请先 `jv exit` 退出当前表，再尝试该操作！

        sheet_not_exists: |
          表 `%{name}` 不存在！

        sheet_drop_failed: |
          放弃表失败：%{err}

        no_holder: |
          表 `%{name}` 没有持有人！

        not_owner: |
          您不是表 `%{name}` 的持有人，无法放弃该表！

    change_edit_right:
      failed:
        none: |
          没有处理任何文件！

      success:
        hold: |
          成功持有 %{num} 个文件！

        throw: |
          成功丢弃 %{num} 个文件！

        mixed: |
          成功修改 %{num} 个文件的编辑权！
          持有 %{num_hold}，丢弃 %{num_throw}

    track:
      done: |
        追踪 %{count} 个文件至最新！
        其中，创建 %{created}，更新 %{updated}，同步 %{synced}

      tip_has_skipped: |
        **注意**：忽略 %{skipped_num} 个同步任务
        %{skipped}
        因本地存在修改，同步任务会强制覆盖您的修改，请确认您确实要覆盖这些文件
        使用 `jv track . --overwrite` 确认覆盖它们

      structure_changes_not_solved: |
        本地存在丢失项和移动项未解决！
        **提示**：使用 `jv align` 查看需要解决的项

      create_failed:
        sheet_not_found: |
          在上游库中不存在表 `%{name}`！
          这意味着该表在上游库中已被删除，或该表不属于您

        create_file_on_exist_path: |
          创建文件失败！
          您要创建的文件路径 `%{path}` 在远程表中已存在，请更换至其他路径创建

      update_failed:
        verify:
          sheet_not_found: 表 %{sheet_name} 不存在！
          mapping_not_found: |
            无法从表中获得路径 %{path} 的映射！
            这说明文件在表中不存在，如果您本地存在该路径，可能说明文件被删除了
            请使用 `jv update` 更新工作区后再尝试

          virtual_file_not_found: |
            无法从映射中读取虚拟文件ID %{vfid}
            这说明映射存在于表中，但实际的文件信息丢失！
            请联系上游库管理员了解情况

          virtual_file_read_failed: |
            无法从映射中读取虚拟文件 %{vfid} 的元数据
            这说明虽然文件存在，但是映射信息损坏了！
            请联系上游库管理员了解情况

          not_held: |
            您并未持有文件 %{path}！
            这说明，您在未持有文件的时修改了它，并在尝试更新时被上游库阻拦
            （非常抱歉，JustEnoughVCS 协作基于串行编辑，并行编辑后合并是不允许的）

            **提示**：如果您确实需要更新该文件，可以参考以下步骤：
            1. 首先将文件移动到工作区以外的地方，并重新在此处更新正确的版本
            2. 使用 `jv info <该文件> --holder` 查询正在编辑的成员
            3. 尝试联系他，并描述您的情况，并等待该成员释放编辑权
            4. 释放编辑权后，使用 `jv track <该文件>` 拿到该成员的最新版本
            5. 手动地将您备份的版本合并至最新版本中
            6. 将您修改的最新版更新，然后释放编辑权

            最后：您可以在编辑文件前，使用 `jv here` 查看所在目录的文件状态，以确保自己可以编辑

          version_dismatch: |
            您编辑的文件基准版本和上游库中的版本不匹配！
            您的版本是 %{version_current} 而上游版本是 %{version_latest}，上游库禁止了您的更新

            **提示**：
            您可以使用 `jv jump <文件> %{version_current}` 将版本跳转至您的本地版本，并再次更新
            若您不期望强制覆盖版本，可以选择将文件版本备份，并更新本地版本至最新后，再手动地合并文件并更新

            最后：您可以在编辑文件前，使用 `jv here` 查看所在目录的文件状态，以确保自己可以编辑

          update_but_no_description: |
            您指定的文件中存在更新项，但是您并未指定更新信息
            使用 `jv track <文件> --desc <描述> -v <版本>` 更新文件
            或使用 `jv track . --work` 进入编辑器环境更新

          version_already_exist: |
            您正在更新的文件 %{path} 的版本 %{version} 在上游库中已存在，请使用其他版本号！

    move:
      success: |
        成功修改映射！
        上游信息已变更，请使用 `jv update` 同步至最新信息

      mapping_not_found: |
        映射 `%{path}` 不存在！
        请检查您输入的路径是否正确，或使用 `jv update` 更新工作区状态

      invalid_move:
        no_target: |
          您未指定需要移动的映射 `%{path}` 的目标地址！
          请使用 `jv move <映射> <目标映射名>` 的方式移动映射
          或使用 `jv move <映射> --erase` 将映射擦除

        duplicate_mapping: |
          移动操作失败，因为目标路径 `%{path}` 已存在映射！
          请更换至其他路径，或先擦除已存在的映射

      unknown: |
        未知的移动操作结果！

jvii:
  hints: |
    [^S 保存] [ESC 退出]

  errors:
    no_file_path: "错误：未提供文件路径"
    editor_error: "编辑器错误：%{error}"
    file_error: "文件错误：%{error}"
    file_not_found: "文件不存在：%{path}"
    not_a_file: "路径不是文件：%{path}"
    init_error: "初始化编辑器失败：%{error}"
    raw_mode_error: "启用原始模式失败：%{error}"
    alternate_screen_error: "进入备用屏幕失败：%{error}"
    save_error: "保存文件失败：%{error}"
    render_error: "渲染错误：%{error}"

  messages:
    file_saved: "文件保存成功"
    unsaved_changes: "有未保存的修改！按 Ctrl+S 保存或再次按 Esc 退出"
    modified: " *"

  status:
    lines: " 行"

editor:
  update_editor: |
    # 您正在使用编辑器模式追踪和更新文件
    # 以下文件将被更新：（行首添加 `#` 视为放弃更新，尾部箭头后请填写版本）

    %{modified_lines}
    ----------------------------------------------------------------------
    # 此处填写更新描述，告诉其他成员您做了什么
    %{description}

  modified_line:
    header:
      file_path: |
        # 文件

      old_version: 旧
      new_version: 新
    content:
      arrow: ->
